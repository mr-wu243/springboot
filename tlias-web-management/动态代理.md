# 静态代理

静态代理就是在程序运行之前，代理类字节码.class就已编译好，通常一个静态代理类也只代理一个目标类，代理类和目标类都实现相同的接口。

例子：

```java
public interface Animal {

    void call();

}
```

```java
public class Cat implements Animal {

    @Override
    public void call() {
        System.out.println("喵喵喵 ~");
    }
}
```

如果想要扩展猫在call()方法以前猫饥饿的方法需要定义一个类
```java
public class StaticProxyAnimal implements Animal {

    private Animal impl;

    public StaticProxyAnimal(Animal impl) {
        this.impl = impl;
    }

    @Override
    public void call() {
        System.out.println("猫饥饿");
        impl.call();
    }
}
```

缺点：
* 每一个静态代理只能代理一个实现类，如果还有个dog类，实现了call()的方法，但是要在dog.call()方法之前增加一个狗饥饿的方法需要再定义一个静态代理，复用性不高
* 如果接口Animal中增加了新的方法，不仅实现类cat中要实现方法，而且代理类StaticProxyAnimal也要实现这些方法

# JDK动态代理

动态代理类与静态代理类最主要不同的是，代理类的字节码不是在程序运行前生成的，而是在程序运行时再虚拟机中程序自动创建的

## 实现 InvocationHandler 接口
```java
public class TargetInvoker implements InvocationHandler {
    // 代理中持有的目标类
    private Object target;

    public TargetInvoker(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("jdk 代理执行前");
        Object result = method.invoke(target, args);
        System.out.println("jdk 代理执行后");
        return result;
    }
}
```

invoke方法中的三个参数的含义：
* proxy 代理目标对象的代理对象，它是真实的代理对象。
* method 执行目标类的方法
* args 执行目标类的方法的参数

## 创建JDK动态代理类
```java
public class DynamicProxyAnimal {

    public static Object getProxy(Object target) throws Exception {
        Object proxy = Proxy.newProxyInstance(
                target.getClass().getClassLoader(), // 指定目标类的类加载
                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个，这是一个数组
                new TargetInvoker(target)   // 代理对象处理器
        );
        return proxy;
    }

}
```

newProxyInstance中的三个参数（ClassLoader loader、Class<?>[] interfaces、InvocationHandler h）：
* loader 加载代理对象的类加载器
* interfaces 代理对象实现的接口，与目标对象实现同样的接口
* h 处理代理对象逻辑的处理器，即上面的 InvocationHandler 实现类

## 实现动态代理
```java
public void dynamicProxy() throws Exception {
        Cat cat = new Cat();
        Animal proxy = (Animal) DynamicProxyAnimal.getProxy(cat);
        proxy.call();
    }
```

jdk基于接口实现，如果目标类实现了接口，则推荐使用jdk动态代理

# CGLIB动态代理(AOP的底层实现)
CGLIB 动态代理的实现机制是生成目标类的子类，通过调用父类（目标类）的方法实现，在调用父类方法时再代理中进行增强。

## 实现 MethodInterceptor 接口

相比于 JDK 动态代理的实现，CGLIB 动态代理不需要实现与目标类一样的接口，而是通过方法拦截的方式实现代理

```java
public class TargetInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("CGLIB 调用前");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("CGLIB 调用后");
        return result;
    }
}
```

通过方法拦截接口调用目标类的方法，然后在该被拦截的方法进行增强处理，实现方法拦截器接口的 intercept 方法里面有四个参数：

* obj 代理类对象
* method 当前被代理拦截的方法
* args 拦截方法的参数
* proxy 代理类对应目标类的代理方法

## CGLIB的基本实现

```java
public class CglibProxy {

    public static Object getProxy(Class<?> clazz){
        Enhancer enhancer = new Enhancer();
        // 设置类加载
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new TargetInterceptor());
        // 创建代理类
        return enhancer.create();
    }

}

public class Main {

    @Test
    public void dynamicProxy() throws Exception {
        Animal cat = (Animal) CglibProxy.getProxy(Cat.class);
        cat.call();
    }
}
```

CGLIB动态代理基于类实现，如果目标类未实现接口，建议CGLIB